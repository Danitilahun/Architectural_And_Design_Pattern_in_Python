## Design Pattern Classification by Intent
* Design patterns offer standard solutions for common problems encountered in software design.
* These patterns resemble pre-made blueprints that you can tailor to address recurring design challenges within your codebase.

* Design patterns can be classified based on their intent or purpose.  Here's a breakdown of the common categories:

**1. Creational Patterns:**

*   **Intent:**  Facilitate flexible object creation and promote code reuse. These patterns deal with the *creation* of objects in a controlled and flexible manner, abstracting the instantiation process.
*   **Key Benefit:**  Decouple the client code from the concrete classes being instantiated. This allows for easier modification and extension of the object creation process.
*   **Examples:**
    *   Abstract Factory
    *   Builder
    *   Factory Method
    *   Prototype
    *   Singleton

**2. Structural Patterns:**

*   **Intent:**  Focus on assembling objects and classes into larger structures, while maintaining their adaptability and efficiency. These patterns deal with the *composition* of classes and objects to form larger structures, providing new functionality.
*   **Key Benefit:**  Simplify the design by identifying a simple way to realize relationships between entities. It ensures that when one part of a system changes, the entire structure doesn't need to change as well.
*   **Examples:**
    *   Adapter
    *   Bridge
    *   Composite
    *   Decorator
    *   Facade
    *   Flyweight
    *   Proxy

**3. Behavioral Patterns:**

*   **Intent:**  Focus on efficient interaction and allocation of responsibilities between objects, ensuring effective communication. These patterns deal with *algorithms and assignment of responsibilities* between objects.
*   **Key Benefit:**  Increase flexibility in carrying out communication between objects. They characterize complex control flow and concentrate on how objects interact.
*   **Examples:**
    *   Chain of Responsibility
    *   Command
    *   Interpreter
    *   Iterator
    *   Mediator
    *   Memento
    *   Observer
    *   State
    *   Strategy
    *   Template Method
    *   Visitor

